// Generated by CoffeeScript 1.3.3
(function() {
  var async, events, exists, existsSync, fs, path, _ref, _ref1,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  path = require('path');

  fs = require('fs');

  events = require('events');

  async = require('async');

  existsSync = (_ref = fs.existsSync) != null ? _ref : path.existsSync;

  exists = (_ref1 = fs.exists) != null ? _ref1 : path.exists;

  exports.container = function() {
    var allDeps, argList, autoDep, autoDeps, container, depMissing, factories, get, getSync, haveVisited, load, loadSync, loaddir, loaddirSync, loadfile, notEmpty, register, registerOne, resolve, resolver, tmp, toFactory;
    factories = {};
    tmp = 0;
    register = function(name, func) {
      var hash, _results;
      if (name === Object(name)) {
        hash = name;
        _results = [];
        for (name in hash) {
          func = hash[name];
          _results.push(registerOne(name, func));
        }
        return _results;
      } else {
        return registerOne(name, func);
      }
    };
    registerOne = function(name, func) {
      if (!(func != null)) {
        throw new Error("cannot register null function");
      }
      return factories[name] = toFactory(func);
    };
    loadSync = function(file) {
      var stats;
      if (existsSync(file)) {
        stats = fs.statSync(file);
        if (stats.isDirectory()) {
          return loaddir(file);
        }
      }
      return loadfile(file);
    };
    load = function(file, cb) {
      if (cb == null) {
        return loadSync(file);
      }
      return exists(file, function(exists) {
        if (!exists) {
          return loadfile(file, cb);
        }
        return fs.stat(file, function(err, stats) {
          if (err != null) {
            return cb(err);
          }
          if (stats.isDirectory()) {
            return loaddir(file, cb);
          }
          return loadfile(file, cb);
        });
      });
    };
    loadfile = function(file, cb) {
      var func, module, name;
      module = file.replace(/\.\w+$/, "");
      name = path.basename(module).replace(/\-(\w)/g, function(match, letter) {
        return letter.toUpperCase();
      });
      try {
        func = require(module);
      } catch (err) {
        if (cb != null) {
          return cb(err);
        }
        throw err;
      }
      register(name, func);
      if (cb != null) {
        return cb(null, func);
      }
    };
    loaddir = function(dir, cb) {
      if (cb == null) {
        return loaddirSync(dir);
      }
      return fs.readdir(dir, function(err, filenames) {
        var file, files, loaders, _fn, _i, _len;
        if (err != null) {
          return cb(err);
        }
        files = filenames.map(function(file) {
          return path.join(dir, file);
        });
        loaders = [];
        _fn = function(file) {
          if (!file.match(/\.(js|coffee)$/)) {
            return;
          }
          return loaders.push(function(cb) {
            return fs.stat(file, function(err, stats) {
              if ((err != null) || !stats.isFile()) {
                return cb(err);
              }
              return loadfile(file, cb);
            });
          });
        };
        for (_i = 0, _len = files.length; _i < _len; _i++) {
          file = files[_i];
          _fn(file);
        }
        return async.parallel(loaders, cb);
      });
    };
    loaddirSync = function(dir) {
      var file, filenames, files, stats, _i, _len, _results;
      filenames = fs.readdirSync(dir);
      files = filenames.map(function(file) {
        return path.join(dir, file);
      });
      _results = [];
      for (_i = 0, _len = files.length; _i < _len; _i++) {
        file = files[_i];
        if (!file.match(/\.(js|coffee)$/)) {
          continue;
        }
        stats = fs.statSync(file);
        if (stats.isFile()) {
          _results.push(loadfile(file));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };
    toFactory = function(func) {
      var args, isAsync;
      if (typeof func !== "function") {
        return {
          required: [],
          func: (function() {
            return func;
          })
        };
      }
      args = argList(func);
      isAsync = args[args.length - 1] === "done";
      if (isAsync) {
        args.pop();
      }
      return {
        func: func,
        required: args,
        async: isAsync
      };
    };
    argList = function(func) {
      var match, required;
      match = func.toString().match(/function.*?\(([\s\S]*?)\)/);
      if (!(match != null)) {
        throw new Error("could not parse function arguments: " + (func != null ? func.toString() : void 0));
      }
      required = match[1].split(",").filter(notEmpty).map(function(str) {
        return str.trim();
      });
      return required;
    };
    notEmpty = function(a) {
      return a;
    };
    get = function(name, overrides, cb) {
      var dependencies, _ref2;
      if (typeof overrides === "function") {
        _ref2 = [overrides, null], cb = _ref2[0], overrides = _ref2[1];
      }
      if (cb == null) {
        return getSync.apply(null, arguments);
      }
      if (name == null) {
        return cb(new Error("cannot get dependency without a name"));
      }
      try {
        dependencies = autoDeps(name, overrides);
      } catch (err) {
        return cb(err);
      }
      return async.auto(dependencies, function(err, results) {
        if (err != null) {
          return cb(err);
        }
        return cb(null, results[name]);
      });
    };
    depMissing = function(name) {
      return new Error("dependency '" + name + "' was not registered");
    };
    resolver = new events.EventEmitter;
    autoDep = function(name, overrides) {
      var cb, factory;
      factory = factories[name];
      if (factory == null) {
        return null;
      }
      if ((overrides != null ? overrides[name] : void 0) != null) {
        return (function(cb) {
          return cb(null, overrides[name]);
        });
      }
      cb = function(cb, results) {
        var args, instance, req;
        if (!(overrides != null)) {
          if (factory.instance != null) {
            return cb(null, factory.instance);
          }
          if (factory.resolving) {
            return resolver.once(name, cb);
          }
        }
        args = (function() {
          var _i, _len, _ref2, _results;
          _ref2 = factory.required;
          _results = [];
          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
            req = _ref2[_i];
            _results.push(results[req]);
          }
          return _results;
        })();
        if (factory.async) {
          if (overrides == null) {
            factory.resolving = true;
          }
          args.push(function(err, result) {
            if (err != null) {
              if (overrides == null) {
                resolver.emit(name, err, result);
              }
              return cb(err);
            }
            if (!(overrides != null)) {
              factory.instance = result;
              factory.resolving = false;
              resolver.emit(name, err, result);
            }
            return cb(null, result);
          });
        }
        try {
          instance = factory.func.apply(factory, args);
        } catch (err) {
          return cb(err);
        }
        if (!factory.async) {
          if (overrides == null) {
            factory.instance = instance;
          }
          return cb(null, instance);
        }
      };
      if (factory.required.length === 0) {
        return cb;
      }
      return __slice.call(factory.required).concat([cb]);
    };
    autoDeps = function(name, overrides) {
      var dep, dependencies, _i, _len, _ref2, _ref3;
      if (factories[name] == null) {
        throw depMissing(name);
      }
      dependencies = {};
      _ref2 = [name].concat(__slice.call(allDeps(name, overrides)));
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        dep = _ref2[_i];
        if ((_ref3 = dependencies[dep]) == null) {
          dependencies[dep] = autoDep(dep, overrides);
        }
      }
      return dependencies;
    };
    allDeps = function(name, overrides) {
      var dep, deps, _ref2;
      if (factories[name] == null) {
        throw depMissing(name);
      }
      if ((overrides != null ? overrides[name] : void 0) != null) {
        return [];
      }
      deps = (_ref2 = factories[name].required).concat.apply(_ref2, (function() {
        var _i, _len, _ref2, _results;
        _ref2 = factories[name].required;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          dep = _ref2[_i];
          _results.push(allDeps(dep));
        }
        return _results;
      })());
      if (__indexOf.call(deps, name) >= 0) {
        throw new Error("circular dependency with '" + name + "'");
      }
      return deps.filter(function(dep, i, deps) {
        return deps.lastIndexOf(dep) === i;
      });
    };
    getSync = function(name, overrides, visited) {
      var dependencies, factory, instance, isOverridden;
      if (visited == null) {
        visited = [];
      }
      if (name == null) {
        throw new Error("cannot get dependency without a name");
      }
      isOverridden = overrides != null;
      if (haveVisited(visited, name)) {
        throw new Error("circular dependency with '" + name + "'");
      }
      visited = visited.concat(name);
      factory = factories[name];
      if (!(factory != null)) {
        throw depMissing(name);
      }
      if ((factory.instance != null) && !isOverridden) {
        return factory.instance;
      }
      if (factory.async) {
        throw new Error("dependency '" + name + "' is asynchronous but was requested synchronously");
      }
      dependencies = factory.required.map(function(name) {
        if ((overrides != null ? overrides[name] : void 0) != null) {
          return overrides != null ? overrides[name] : void 0;
        } else {
          return getSync(name, overrides, visited);
        }
      });
      instance = factory.func.apply(factory, dependencies);
      if (!isOverridden) {
        factory.instance = instance;
      }
      return instance;
    };
    haveVisited = function(visited, name) {
      var isName;
      isName = function(n) {
        return n === name;
      };
      return visited.filter(isName).length;
    };
    resolve = function(overrides, func) {
      var name;
      if (!func) {
        func = overrides;
        overrides = null;
      }
      tmp = tmp + 1;
      name = "__temp_" + tmp;
      register(name, func);
      return get(name, overrides, function(err, result) {
        if (factories[name] != null) {
          delete factories[name];
        }
        if (err != null) {
          throw err;
        }
      });
    };
    container = {
      get: get,
      resolve: resolve,
      register: register,
      load: load
    };
    container.register("_container", container);
    return container;
  };

}).call(this);
